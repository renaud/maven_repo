package edu.stanford.nlp.process;

import java.io.Reader;

import edu.stanford.nlp.ling.AbstractMapLabel;
import edu.stanford.nlp.ling.FeatureLabel;


/** Provides a tokenizer or lexer that does a pretty good job at 
 *  deterministically tokenizing according to Penn Treebank conventions.
 *  The class is a scanner generated by
 *  <a href="http://www.jflex.de/">JFlex</a> 1.4.1 from the specification file
 *  <code>PTBLexer.flex</code>.  As well as copying what is in the Treebank,
 *  it now contains some extensions to deal with modern text and encoding 
 *  issues, such as recognizing URLs and common Windows CP1252 characters.
 *  <p>
 *  <i>Implementation note:</i> The scanner is caseless, but note if adding
 *  or changing regexps that caseless does not expand inside character 
 *  classes.  From the manual: "The %caseless option does not change the
 *  matched text and does not effect character classes. So [a] still only
 *  matches the character a and not A, too."  Note that some character
 *  classes still deliberately don't have both cases, so the scanner's
 *  operation isn't completely case-independent, though it mostly is.
 *
 *  @author Tim Grow
 *  @author Christopher Manning
 *  @author Jenny Finkel
 */

%%

%class PTBLexer
%unicode
%function next
%type Object
%char
%caseless

%{

  /**
   * Constructs a new PTBLexer with a custom LexedTokenFactory.
   *
   * @param r The Reader to tokenize text from
   * @param tf The LexedTokenFactory that will be invoked to convert
   *  each substring extracted by the lexer into some kind of Object (
   *  such as a Word). 
   */
  public PTBLexer(Reader r, LexedTokenFactory tf, boolean tokenizeCRs) {
    this(r, tf, tokenizeCRs, false);
  }


  /**
   * Constructs a new PTBLexer which suppresses PTB token transforms
   * (like -LRB-, -RRB-).
   *
   * @param suppressEscaping if true, suppress the PTB token transform and 
   * keep the original ones
   */
  public PTBLexer(Reader r, LexedTokenFactory tf, boolean tokenizeCRs, boolean suppressEscaping) {
    this(r);
    this.invertable = false;
    tokenFactory = tf;
    this.tokenizeCRs = tokenizeCRs;
    // System.err.println("DEBUG: suppressEscaping="+suppressEscaping);
    this.suppressEscaping = suppressEscaping;
  }


  /**
   * Constructs a new PTBLexer which produces FeatureLabels.
   *
   * @param r The Reader to tokenize text from
   * @param invertable If the invertable flag is set to true then the
   * produced FeatureLabels will contain fields for the text
   * both before and after the current token (but after the 
   * previous token and before the next token) and the
   * original version of this word, and the character offset
   * for when the token begins and ends. In this case the tokenFactory
   * necessarily vends FeatureLabels.
   */
  public PTBLexer(Reader r, boolean invertable, boolean tokenizeCRs) {
    this(r);
    tokenFactory = new FeatureLabelTokenFactory();
    this.invertable = invertable;
    this.tokenizeCRs = tokenizeCRs;
    // System.err.println("invertable2: "+this.invertable);
  }


  /*
   * This has now been extended to cover the main Windows CP1252 characters,
   * at either their correct Unicode codepoints, or in their invalid
   * positions as 8 bit chars inside the iso-8859 control region.
   *
   * ellipses  	85  	0133  	2026  	8230
   * single quote curly starting 	91 	0145 	2018 	8216 	
   * single quote curly ending 	92 	0146 	2019 	8217
   * double quote curly starting 	93 	0147 	201C 	8220
   * double quote curly ending 	94 	0148 	201D 	8221
   * en dash  	96  	0150  	2013  	8211
   * em dash  	97  	0151  	2014  	8212
   */

  public static final String opendblquote = "``";
  public static final String closedblquote = "''";
  public static final String openparen = "-LRB-";
  public static final String closeparen = "-RRB-";
  public static final String openbrace = "-LCB-";
  public static final String closebrace = "-RCB-";
  public static final String ptbmdash = "--";
  public static final String ptbellipsis = "...";
  /** For tokenizing carriage returns.  (JS) */
  public static final String cr = "*CR*"; 

  /** This quotes a character with a backslash, but doesn't do it
   *  if the character is already preceded by a backslash.
   */
  private static String delimit (String s, char c) {
    int i = s.indexOf(c);
    while (i != -1) {
      if (i == 0 || s.charAt(i - 1) != '\\') {
        s = s.substring(0, i) + "\\" + s.substring(i);
        i = s.indexOf(c, i + 2);
      } else {
        i = s.indexOf(c, i + 1);
      } 
    }
    return s;
  }

  private static String normalizeCp1252(String in) {
    String s1 = in;
    // s1 = s1.replaceAll("[\u0085\u2026]", "..."); // replaced directly
    // s1 = s1.replaceAll("[\u0096\u0097\u2013\u2014]", "--");
    s1 = s1.replaceAll("&apos;", "'");
    // s1 = s1.replaceAll("&quot;", "\""); // replaced directly
    s1 = s1.replaceAll("[\u0091\u2018]", "`");
    s1 = s1.replaceAll("[\u0092\u2019]", "'");
    s1 = s1.replaceAll("[\u0093\u201C]", "``");
    s1 = s1.replaceAll("[\u0094\u201D]", "''");
    s1 = s1.replaceAll("\u00BC", "1\\/4");
    s1 = s1.replaceAll("\u00BD", "1\\/2");
    s1 = s1.replaceAll("\u00BE", "3\\/4");
    s1 = s1.replaceAll("\u00A2", "cents");
    s1 = s1.replaceAll("\u00A3", "#");
    s1 = s1.replaceAll("[\u0080\u20AC]", "$");  // Euro -- no good translation!
    return s1;
  }

  private static String normalizeAmp(final String in) {
    return in.replaceAll("(?i:&amp;)", "&");
  }

  private LexedTokenFactory tokenFactory;
  private boolean invertable;
  private boolean tokenizeCRs;
  private boolean suppressEscaping;

  private FeatureLabel prevWord = new FeatureLabel();

  private Object getNext() {
    return getNext(yytext(), yytext());
  }

  private Object getNext(String txt, String current) {
    if (!invertable) { 
      return tokenFactory.makeToken(txt, yychar, yylength());
    }
    FeatureLabel word = (FeatureLabel)tokenFactory.makeToken(txt, yychar, yylength());  
    word.put(AbstractMapLabel.CURRENT_KEY, current);
    word.put(AbstractMapLabel.BEFORE_KEY, prevWord.get(AbstractMapLabel.AFTER_KEY));
    prevWord = word;
    return prevWord;
  }

%}

SGML = <\/?[A-Za-z!][^>]*>
SPMDASH = &(MD|mdash);|[\u0096\u0097\u2013\u2014]
SPAMP = &amp;
SPPUNC = &(HT|TL|UR|LR|QC|QL|QR|odq|cdq|lt|gt|#[0-9]+);
SPLET = &[aeiouAEIOU](acute|grave|uml);
SPACE = [ \t]+
SPACENL = [ \t\r\n]+
SENTEND = [ \t\n][ \t\n]+|[ \t\n]+([A-Z]|{SGML})
DIGIT = [0-9]
DATE = {DIGIT}{1,2}[\-\/]{DIGIT}{1,2}[\-\/]{DIGIT}{2,4}
NUM = {DIGIT}+|{DIGIT}*([.:,]{DIGIT}+)+
NUMBER = [\-+]?{NUM}|\({NUM}\)
FRAC = ({DIGIT}+[- ])?{DIGIT}+\\?\/{DIGIT}+
FRAC2 = [\u00BC\u00BD\u00BE]
DOLSIGN = ([A-Z]*\$|#)
DOLSIGN2 = [\u00A2\u00A3\u0080\u20AC]
/* not used DOLLAR	{DOLSIGN}[ \t]*{NUMBER}  */
/* |\( ?{NUMBER} ?\))	 # is for pound signs */
WORD = ([A-Za-z\u00C0-\u00FF]|{SPLET})+
/* The $ was for things like New$ */
/* WAS: only keep hyphens with short one side like co-ed */
/* But treebank just allows hyphenated things as words! */
THING = [A-Za-z0-9]+([_-][A-Za-z0-9]+)*
THINGA = [A-Z]+(([+&]|{SPAMP})[A-Z]+)+
THING3 = [A-Za-z0-9]+(-[A-Za-z]+){0,2}(\\?\/[A-Za-z0-9]+(-[A-Za-z]+){0,2}){1,2}
APOS = ['\u0092\u2019]|&apos;
HTHING = ([A-Za-z0-9][A-Za-z0-9%.,]*(-([A-Za-z0-9]+|{ACRO}\.))+)|[dDOlL]{APOS}{THING}
REDAUX = {APOS}([msdMSD]|re|ve|ll)
/* For things that will have n't on the end. They can't end in 'n' */
SWORD = [A-Za-z]*[A-MO-Za-mo-z]
SREDAUX = n{APOS}t
/* Tokens you want but already okay: C'mon 'n' '[2-9]0s '[eE]m 'till?
   [Yy]'all 'Cause Shi'ite B'Gosh o'clock.  Here now only need apostrophe
   final words. */
APOWORD = {APOS}n{APOS}?|[lLdDjJ]'|Dunkin{APOS}|somethin{APOS}|ol{APOS}|{APOS}em|C{APOS}mon|{APOS}[2-9]0s|{APOS}till?|o{APOS}clock|Shi{APOS}ite|{APOS}cause
FULLURL = https?:\/\/[^ \t\n\f\r\"<>|()]+[^ \t\n\f\r\"<>|.!?(){},-]
LIKELYURL = ((www\.([^ \t\n\f\r\"<>|.!?(){},]+\.)+[a-zA-Z]{2,4})|(([^ \t\n\f\r\"`'<>|.!?(){},-_$]+\.)+(com|net|org|edu)))(\/[^ \t\n\f\r\"<>|()]+[^ \t\n\f\r\"<>|.!?(){},-])?
EMAIL = [a-zA-Z0-9][^ \t\n\f\r\"<>|()]*@([^ \t\n\f\r\"<>|().]+\.)+[a-zA-Z]{2,4}

/* Abbreviations - induced from 1987 WSJ by hand */
ABMONTH = Jan|Feb|Mar|Apr|Jun|Jul|Aug|Sep|Sept|Oct|Nov|Dec
/* Jun and Jul barely occur, but don't seem dangerous */
ABDAYS = Mon|Tue|Tues|Wed|Thu|Thurs|Fri
/* In caseless, |a\.m|p\.m handled as ACRO, and this is better as can often
   be followed by capitalized. */
/* Sat. and Sun. barely occur and can easily lead to errors, so we omit them */
ABSTATE = Calif|Mass|Conn|Fla|Ill|Mich|Pa|Va|Ariz|Tenn|Mo|Md|Wis|Minn|Ind|Okla|Wash|Kan|Ore|Ga|Colo|Ky|Del|Ala|La|Nev|Neb|Ark|Miss|Vt|Wyo|Tex
ACRO = [A-Za-z](\.[A-Za-z])+|(Canada|Sino|Korean|EU|Japan|non)-U\.S|U\.S\.-(U\.K|U\.S\.S\.R)
ABTITLE = Mr|Mrs|Ms|Miss|Drs?|Profs?|Sens?|Reps?|Lt|Col|Gen|Messrs|Govs?|Adm|Rev|Maj|Sgt|Pvt|Mt|Capt|Sens|St|Ave
ABPTIT = Jr|Bros|Sr
ABCOMP = Inc|Cos?|Corp|Pty|Ltd|Plc|Bancorp|Dept|Mfg|Bhd|Assn
ABNUM = Nos?|Prop|Ph
/* p used to be in ABNUM list, but it can't be any more, since the lexer
   is now caseless.  We don't want to have it recognized for P.  Both
   p. and P. are now under ABBREV4. ABLIST also went away as no-op [a-e] */
/* ABBREV1 abbreviations are normally followed by lower case words.  If
   they're followed by an uppercase one, we assume there is also a
   sentence boundary */
ABBREV3 = {ABMONTH}|{ABDAYS}|{ABSTATE}|{ABCOMP}|{ABNUM}|{ABPTIT}|etc|ft
ABBREV1 = {ABBREV3}\.


/* ABRREV2 abbreviations are normally followed by an upper case word.  We
   assume they aren't used sentence finally */
/* ACRO Is a bad case -- can go either way! */
ABBREV4	= [A-Za-z]|{ABTITLE}|vs|Alex|Cie|a\.k\.a|TREAS|{ACRO}
ABBREV2	= {ABBREV4}\.
/* Cie. is used before French companies */
/* in the WSJ Alex. is generally an abbreviation for Alex. Brown, brokers! */
/* In tables: Mkt. for market Div. for division of company, Chg., Yr.: year */

PHONE = \([0-9]{3}\)\ ?[0-9]{3}[\- ][0-9]{4}
OPBRAC = [<\[]
CLBRAC = [>\]]
HYPHENS = \-+
LDOTS = \.{3,5}|(\.\ ){2,4}\.|[\u0085\u2026]
ATS = @+
UNDS = _+
ASTS = \*+|(\\\*){1,3}
HASHES = #+
FNMARKS = {ATS}|{HASHES}|{UNDS}
INSENTP =[,;:]
QUOTES =`|{APOS}|``|''|[\u2018\u2019\u201C\u201D\u0091\u0092\u0093\u0094]{1,2}
DBLQUOT = \"|&quot;
TBSPEC = -(RRB|LRB|RCB|LCB|RSB|LSB)-|C\.D\.s|D'Amico|M'Bow|pro-|anti-|S&P-500|Jos\.|cont'd\.?|B'Gosh|S&Ls|N'Ko|'twas
TBSPEC2 = {APOS}[0-9][0-9]

%%

cannot			{ yypushback(3) ; return getNext(); }
{SGML}			{ return getNext(); }
{SPMDASH}		{ if (!suppressEscaping) {
                            return getNext(ptbmdash, yytext()); }
                          else {
                            return getNext();
                          }
                        }
{SPAMP}			{ if (!suppressEscaping) {
                            return getNext("&", yytext()); }
                          else {
                            return getNext();
                          }
                        }
{SPPUNC}		{ return getNext(); }
{WORD}/{REDAUX}		{ return getNext(); }
{SWORD}/{SREDAUX}	{ yypushback(1); return getNext(); }
{WORD}			{ if (!suppressEscaping) {
                            String word = Americanize.americanize(yytext());
                            return getNext(word, yytext()); }
                          else {
                            return getNext();
                          }
                        }
{APOWORD}		{ return getNext(); }
{FULLURL}		{ return getNext(); }
{LIKELYURL}	        { return getNext(); }
{EMAIL}			{ return getNext(); }
{REDAUX}/[^A-Za-z]	{ if (!suppressEscaping) {
                            return getNext(normalizeCp1252(yytext()), yytext()); }
                          else {
                            return getNext();
                          }
                        }
{SREDAUX}		{ if (!suppressEscaping) {
                            return getNext(normalizeCp1252(yytext()), yytext()); }
                          else {
                            return getNext();
                          }
                        }
{DATE}			{ return getNext(); }
{NUMBER}		{ return getNext(); }
{FRAC}			{ if (!suppressEscaping) {
                            return getNext(delimit(yytext(), '/'), yytext()); }
                          else {
                            return getNext();
                          }
                        }
{FRAC2}			{ if (!suppressEscaping) {
                            return getNext(normalizeCp1252(yytext()), yytext()); }
                          else {
                            return getNext();
                          }
                        }
{TBSPEC}		{ return getNext(); }
{THING3}		{ if (!suppressEscaping) {
                            return getNext(delimit(yytext(), '/'), yytext()); }
                          else {
                            return getNext();
                          }
                        }
{DOLSIGN}		{ return getNext(); }
{DOLSIGN2}		{ if (!suppressEscaping) {
                            return getNext(normalizeCp1252(yytext()), yytext()); }
                          else {
                            return getNext();
                          }
                        }
{ABBREV1}/{SENTEND}	{ String s = yytext();                      
			  yypushback(1);  // return a period for next time
	                  return getNext(s, yytext()); }
{ABBREV1}		{ return getNext(); }
{ABBREV2}		{ return getNext(); }
{ABBREV4}/{SPACE}	{ return getNext(); }
{ACRO}/{SPACENL}	{ return getNext(); }
{TBSPEC2}/{SPACENL}	{ return getNext(); }
{WORD}\./{INSENTP}	{ return getNext(); }
{PHONE}			{ return getNext(); }
{DBLQUOT}/[A-Za-z0-9$]	{ if (!suppressEscaping) {
                            return getNext(opendblquote, yytext()); }
                          else {
                            return getNext();
                          }
                        }
{DBLQUOT}		{ if (!suppressEscaping) {
                            return getNext(closedblquote, yytext()); }
                          else {
                            return getNext();
                          }
                        }
\+		{ return getNext(); }
%|&		{ return getNext(); }
\~|\^		{ return getNext(); }
\||\\|0x7f	{ if (invertable) {
                     if (prevWord == null) {
                       prevWord = new FeatureLabel();
                     }
                     prevWord.appendAfter(yytext()); 
                  }}
{OPBRAC}	{ if (!suppressEscaping) {
                    return getNext(openparen, yytext()); }
                  else {
                    return getNext();                  
                  }
                }
{CLBRAC}	{ if (!suppressEscaping) {
                    return getNext(closeparen, yytext()); }
                  else {
                    return getNext();
                  }
                }
\{		{ if (!suppressEscaping) {
                    return getNext(openbrace, yytext()); }
                  else {
                    return getNext();
                  }
                }
\}		{ if (!suppressEscaping) {
                    return getNext(closebrace, yytext()); }
                  else {
                    return getNext();
                  }
                }
\(		{ if (!suppressEscaping) {
                    return getNext(openparen, yytext()); }
                  else {
                    return getNext();
                  }
                }
\)		{ if (!suppressEscaping) {
                    return getNext(closeparen, yytext()); }
                  else {
                    return getNext();
                  }
                }
{HYPHENS}	{ if (yylength() >= 3 && yylength() <= 4 && !suppressEscaping) {
	            return getNext(ptbmdash, yytext());
                  } else {
                    return getNext();
		  }
		}
{LDOTS}		{ if (!suppressEscaping) {
                    return getNext(ptbellipsis, yytext()); }
                  else {
                    return getNext();
                  }
                }
{FNMARKS}	{ return getNext(); }
{ASTS}		{ if (!suppressEscaping) {
                    return getNext(delimit(yytext(), '*'), yytext()); }
                  else {
                    return getNext();
                  }
                }
{INSENTP}	{ return getNext(); }
\.|\?|\!	{ return getNext(); }
=		{ return getNext(); }
\/		{ if (!suppressEscaping) {
                    return getNext(delimit(yytext(), '/'), yytext()); }
                  else {
                    return getNext();
                  }
                }
{HTHING}/[^a-zA-Z0-9.+]    { return getNext(); }
{THING}		{ return getNext(); }
{THINGA}	{ if (!suppressEscaping) {
                    return getNext(normalizeAmp(yytext()), yytext()); }
                  else {
                    return getNext();
                  }
                }
'[A-Za-z].	{ /* invert quote - using trailing context didn't work.... */ 
                  String str = yytext();
		  yypushback(2);
                  if (!suppressEscaping) {
                    return getNext("`", str); }
                  else {
                    return getNext(str,str);
                  }
                }
{REDAUX}	{ if (!suppressEscaping) {
                    return getNext(normalizeCp1252(yytext()), yytext()); }
                  else {
                    return getNext();
                  }
                }
{QUOTES}	{ if (!suppressEscaping) {
                    return getNext(normalizeCp1252(yytext()), yytext()); }
                  else {
                    return getNext();
                  }
                }
\0|{SPACE}	{ if (invertable) {
                     if (prevWord == null) {
                       prevWord = new FeatureLabel();
                     }
                     prevWord.appendAfter(yytext()); 
                } }
\n|\r|\r\n	{ if (tokenizeCRs) {
                      return getNext(cr, yytext()); // js: for tokenizing carriage returns
                  } else if (invertable) {
                      prevWord.appendAfter(yytext());
                } }
&nbsp;		{ if (invertable) {
                     if (prevWord == null) {
                       prevWord = new FeatureLabel();
                     }
                     prevWord.appendAfter(yytext()); 
                } }
.		{ String str = yytext();
                  if (invertable) { prevWord.appendAfter(str); }
                  int first = str.charAt(0);
		  System.err.println("Untokenizable: " + yytext() +
			     " (first char in decimal: " + first + ")"); }
<<EOF>> { if (invertable) { prevWord.appendAfter(yytext()); }  
          return null; }
